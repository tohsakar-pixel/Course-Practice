/*# B3631 单向链表

## 题目描述

实现一个数据结构，维护一张表（最初只有一个元素 1）。需要支持下面的操作，其中
x 和 y 都是 1 到 10^6
范围内的正整数，且保证任何时间表中所有数字均不相同，操作数量不多于 10^5：

- `1 x y` ：将元素 y 插入到 x 后面；
- `2 x` ：询问 x 后面的元素是什么。如果 x 是最后一个元素，则输出 0；
- `3 x`：从表中删除元素 x 后面的那个元素，不改变其他元素的先后顺序。

## 输入格式

第一行一个整数 q 表示操作次数。

接下来 q 行，每行表示一次操作，操作具体见题目描述。

## 输出格式

对于每个操作 2，输出一个数字，用换行隔开。

## 输入输出样例 #1

### 输入 #1

```
6
1 1 99
1 99 50
1 99 75
2 99
3 75
2 1
```

### 输出 #1

```
75
99
```*/

#include <stdio.h>

// 定义最大节点数
#define MAXN 1000005

// 定义数组：ne存储每个节点的下一个节点索引，val存储节点的值，idx用于记录当前节点数
int ne[MAXN], val[MAXN], idx = 1;

// 遍历打印模拟链表（题目没有要求）
void print_list()
{
    int p = 0; // 从头节点开始
    while (p != -1)
    {                          // 直到链表结束
        printf("%d ", val[p]); // 打印当前节点的值
        p = ne[p];             // 移动到下一个节点
    }
    printf("\n");
}

int main()
{
    // 初始化头节点，其下一个节点为-1（表示不存在），值为1
    ne[0] = -1;
    val[0] = 1;

    int n;
    // 读取操作次数
    scanf("%d", &n);
    while (n--)
    {
        int op;
        // 读取操作类型
        scanf("%d", &op);
        if (op == 1)
        {
            // 插入操作：读取要插入的值x和要插入到其后的值y
            int x, y;
            scanf("%d %d", &x, &y);
            int p = 0;
            // 查找值为x的节点
            while (p != -1 && val[p] != x)
                p = ne[p];
            if (p != -1)
            {
                // 创建新节点，值为y
                val[idx] = y;
                // 新节点的下一个节点指向当前节点的下一个节点
                ne[idx] = ne[p];
                // 当前节点的下一个节点指向新节点
                ne[p] = idx++;
            }
        }
        else if (op == 2)
        {
            // 查询操作：读取要查询的值x
            int x;
            scanf("%d", &x);
            int p = 0;
            // 查找值为x的节点
            while (p != -1 && val[p] != x)
                p = ne[p];
            // 输出x的下一个节点的值，如果不存在则输出0
            printf("%d\n", (p != -1 && ne[p] != -1) ? val[ne[p]] : 0);
        }
        else
        {
            // 删除操作：读取要删除的值x的下一个节点
            int x;
            scanf("%d", &x);
            int p = 0;
            // 查找值为x的节点
            while (p != -1 && val[p] != x)
                p = ne[p];
            // 如果找到x且x的下一个节点存在，则跳过x的下一个节点（即删除）
            if (p != -1 && ne[p] != -1)
                ne[p] = ne[ne[p]];
        }
    }
    return 0;
}
